[header]
name = "volllly Key Bindings"
version = "1.0.0"

requiredExtensions = [
  "dbankier.vscode-quick-select",
  "pustelto.bracketeer",
  "wmaurer.change-case",
  "haberdashPI.selection-utilities",
]

[[mode]]
name = "insert"
lineNumbers = "on"
recordEdits = true

[[mode]]
name = "normal"
default = true
highlight = "Highlight"
cursorShape = "Block"
lineNumbers = "relative"

[[mode]]
name = "selectedit"
highlight = "Highlight"
cursorShape = "BlockOutline"
lineNumbers = "relative"

[define]
select_on = false
around_on = false

[[kind]]
name = "motion"
description = "These commands move the cursor and/or selections."

[[kind]]
name = "action"
description = """
Actions do something with the selected text (e.g. delete it). Unless otherwise noted, in
the absence of a selection, an action will modify an entire line, and a count argument
indicates the number of lines (e.g. 3d deletes this line and the next 3 lines).
"""

[[kind]]
name = "util"
description = """
Assorted other commands that aren't motions or actions
"""

[[define.selectLinesDown]]
command = "selection-utilities.shrinkToActive"

[[define.selectLinesDown]]
if = "count"
command = "cursorMove"
args = { to = "down", by = "wrappedLine", select = true }
computedArgs = { value = "count" }

[[define.selectLinesDown]]
command = "expandLineSelection"

[[define.selectLinesUp]]
command = "selection-utilities.shrinkToActive"

[[define.selectLinesUp]]
if = "count"
command = "cursorMove"
args = { to = "up", by = "wrappedLine", select = true }
computedArgs = { value = "count" }

[[define.selectLinesUp]]
command = "expandLineSelection"


[[path]]
id = "modes"
name = "Modes"
default.kind = "util"

# ## Getting Help

# There are three kinds of help available in Master Key.

# 1. The visual documentation shows up in the lower pane and shows the currently available bindings on-top of a keyboard layout.
# 2. The text documentation is what you are reading now.
# 3. The suggestion palette shows a list of the current bindings given the current key binding prefix.

[[bind]]
path = "util"
key = "shift+;"
name = "suggest"
resetTransient = false
hideInPalette = true
prefixes = []
mode = ["!capture", "!insert"]
description = """
show command suggestions within the context of the current mode and keybinding prefix (if any). E.g. `TAB, ⇧;` in `normal` mode will show all `normal` command suggestions that start with `TAB`.
"""
command = "master-key.commandSuggestions"

[[bind]]
key = "tab /"
name = "text docs"
priority = -1
mode = "normal"
description = "Show text documentation for keybindings"
command = "master-key.showTextDoc"

[[bind]]
key = "tab shift+/"
name = "visual doc"
priority = -1
mode = "normal"
description = "Show visual documentation for keybindings"
command = "master-key.showVisualDoc"

[[bind]]
key = "space"
name = "whichkey"
priority = -1
mode = "normal"
description = "Open the whichkey popup"
command = "vspacecode.space"
when = "editorTextFocus"

# The visual keybinding documentation is modified by three additional commands that can be used to determine which modifiers are shown.

# - `Master Key: Toggle Visual Doc Modifier by frequency`: changes keybinding modifiers from most to least common modifiers across all modifiers defined by the current keybindings.
#
# - `Master Key: Toggle Visual Doc Modifier for Top of Key`: allows you to explicitly change the modifier shown on the top of a key.
# - `Master Key: Toggle Visual Doc Modifier for Bottom of Key`: allows you to explicitly change the modifier shown on the bottom of a key.
#
# There are no keybindings for these commands by default.

# ## Normal Mode

# The default mode in Larkin, is Normal. In this mode, instead of the keys entering text, all keys are commands that modify selections or perform actions on those selections. To exit normal mode you can use `i` to enter `insert` mode, which returns VSCode keybindings to their normal state (see [Simple actions](#simple-actions) for more ways to enter insert mode).

# While in Normal model you will see a highlighted section with the text "normal" in the lower left hand corner of the status bar.

# |mode|key|name|description|
# |---|----|----|-----------|
# |`-`|`ESC` or `^[`|normal|enter normal mode|
#

[[bind]]
path = "modes"
name = "normal"
description = "Enter normal mode"
foreach.key = ["escape", "ctrl+["]
combinedKey = "escape/ctrl+["
combinedName = "normal"
combinedDescription = "Enter normal mode"
key = "{key}"
mode = []
hideInPalette = true
hideInDocs = false
command = "master-key.enterNormal"
when = "!findWidgetVisible"
prefixes = "<all-prefixes>"

[[bind]]
path = "modes"
name = "normal"
foreach.key = ["escape", "ctrl+["]
key = "{key}"
hideInPalette = true
hideInDocs = true
when = "suggestWidgetVisible && editorTextFocus && !findWidgetVisible"
command = "runCommands"
args.commands = ["hideSuggestWidget", "master-key.enterNormal"]
mode = []
prefixes = "<all-prefixes>"

#- in "command" like modes (e.g. normal), typing keys without a command defined below should have no effect
[[bind]]
path = "modes"
name = "ignore"
description = "this key does nothing"
foreach.key = [
  '{key: .}',
  'shift+{key: .}',
] #- all keys whose bindings are described by a single character
key = "{key}"
command = "master-key.ignore"
prefixes = "<all-prefixes>"
mode = ["normal", "selectedit"]
when = "editorTextFocus"
hideInDocs = true
hideInPalette = true
priority = -10

[[path]]
id = "edit"
name = "Editor Commands"
when = "editorTextFocus && !findWidgetVisible"
default.mode = "normal"

[[path]]
id = "edit.count"
name = "count"
default.kind = "count"

# ## Basic motions

# These are the most common, simple motions that can be performed in Larkin.

# Selection behavior uses the following logic: motions that move more than one character generally select the text "under" the motion. If a selection already exists (e.g. from a previous motion) additional motions extend that selection. You can always reset the selection using `v`, and several commands (e.g. `x`) operate on the next character rather than the current selection.

[[path]]
id = "edit.motion"
name = "Motions"
description = "Commands that move the cursors and/or selections"
default.kind = "motion"

[[path]]
id = "edit.motion.prim"
name = "Primitive Motions"
description = "Motions fundamental to moving around in the editor."
default.command = "cursorMove"
default.computedArgs.value = "count"
default.computedArgs.select = "editorHasSelection || select_on"

[[bind]]
path = "edit.motion.prim"
key = "h"
name = "←"
combinedName = "←/→"
combinedKey = "h/l"
combinedDescription = "move left/right"
description = "move left"
args.to = "left"
mode = "normal"

[[bind]]
path = "edit.motion.prim"
key = "l"
combinedName = "←/→"
name = "→"
description = "move right"
args.to = "right"

[[bind]]
path = "edit.motion.prim"
key = "j"
name = "↓"
combinedName = "↓/↑"
combinedKey = "j/k"
combinedDescription = "move down/up"
description = "move down"
args.to = "down"
args.by = "wrappedLine"

[[bind]]
path = "edit.motion.prim"
key = "k"
name = "↑"
description = "move up"
combinedName = "↓/↑"
args.to = "up"
args.by = "wrappedLine"

[[bind]]
path = "edit.motion.prim"
key = "shift+h"
name = "start"
description = "start of line (alternates between first non-white and first)"
combinedName = "start/end"
combinedKey = "shift+h/shift+l"
combinedDescription = "move to start/end of line"
command = "cursorHomeSelect"

[[bind]] # we don't use prim because we don't want the defaults
path = "edit.motion"
key = "shift+l"
name = "end"
combinedName = "start/end"
description = "end of line"
command = "cursorMove"
args.to = "wrappedLineEnd"
args.select = true

[[bind]]
path = "edit.motion.prim"
key = "shift+k"
name = "sel ↑"
combinedName = "sel ↑/↓"
combinedDescription = "select lines up/down"
combinedKey = "shift+k/shift+j"
description = "select lines upwards"
command = "runCommands"

[[bind.args.commands]]
command = "selection-utilities.shrinkToActive"

[[bind.args.commands]]
command = "cursorMove"
args = { to = "up", by = "wrappedLine", select = true }
computedArgs = { value = "count" }

[[bind.args.commands]]
command = "expandLineSelection"

[[bind.args.commands]]
command = "selection-utilities.exchangeAnchorActive"

[[bind]]
path = "edit.motion.prim"
key = "shift+j"
name = "sel ↓"
combinedName = "sel ↑/↓"
description = "select lines downwards"
command = "runCommands"

[[bind.args.commands]]
command = "selection-utilities.shrinkToActive"

[[bind.args.commands]]
command = "cursorMove"
args = { to = "down", by = "wrappedLine", select = true }
computedArgs = { value = "count" }

[[bind.args.commands]]
command = "expandLineSelection"

[[bind]]
path = "edit.motion.prim"
key = "ctrl+d"
mode = ["normal", "insert"]
name = "pg ↓"
combinedName = "pg ↓/↑"
combinedKey = "ctrl+d/ctrl+u"
combinedDescription = "move down/up, relative to page size"
description = "move down, relative to page size"
command = "selection-utilities.activePageMove"
args.dir = "down"
computedArgs.count = "(count || 1)/3"
computedArgs.select = "mode == 'normal'"

[[bind]]
path = "edit.motion.prim"
key = "ctrl+u"
mode = ["normal", "insert"]
name = "pg ↑"
combinedName = "pg ↓/↑"
description = "move up, relative to page size"
command = "selection-utilities.activePageMove"
args.dir = "up"
computedArgs.count = "(count || 1)/3"
computedArgs.select = "mode == 'normal'"

[[bind]]
path = "edit.motion.prim"
key = "shift+x"
name = "exapand"
description = "expand selections to full lines"
command = "expandLineSelection"
repeat = "count"

[[path]]
id = "edit.motion.obj"
name = "Motions defined by various regex and syntactical objects"
description = """
motions that move by a predefined syntactic object (e.g. word, paragraph, etc...)
"""
default.command = "selection-utilities.moveBy"
default.args.boundary = "start"
default.args.select = true

[[bind]]
path = "edit.motion.obj"
key = "w"
name = "subwrd →"
description = "next subword (camel/snake case)"
combinedName = "subwrd ←/→"
combinedDescription = "next/prev subword (camel/snake case)"
combinedKey = "w/b"
args.unit = "subword"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "b"
name = "subwrd ←"
description = "previous subword (camel/snake case)"
combinedName = "subwrd ←/→"
args.unit = "subword"
computedArgs.value = "-count || -1"

[[bind]]
path = "edit.motion.obj"
key = "shift+w"
name = "word →"
description = "next word"
combinedName = "word ←/→"
combinedDescription = "next/prev word"
combinedKey = "shift+w/b"
args.unit = "word"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "shift+b"
name = "word ←"
combinedName = "word ←/→"
description = "previous word"
prefixes = [""]
args.unit = "word"
computedArgs.value = "-count || -1"

[[bind]]
path = "edit.motion.obj"
key = "e"
name = "subwrd end"
description = "next subword (camel/snake case) end"
args.unit = "subword"
args.boundary = "end"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "shift+e"
name = "word end"
description = "next word end"
args.unit = "word"
args.boundary = "end"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "shift+]"
name = "parag. →"
description = "next paragraph"
combinedName = "paragraph →/←"
combinedDescription = "next/previous paragraph"
combinedKey = "shift+]/["
args.unit = "paragraph"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "shift+["
name = "parag. ←"
combinedName = "paragraph →/←"
description = "previous paragraph"
args.unit = "paragraph"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.obj"
key = "shift+0"
name = "subsec →"
description = "next subsection"
combinedName = "subsec →/←"
combinedDescription = "next/previous subsection"
combinedKey = "shift+0/9"
args.unit = "subsection"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "shift+9"
name = "subsec ←"
description = "previous subsection"
combinedName = "subsec →/←"
args.unit = "subsection"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.prim"
key = "v"
name = "shrink selection"
combinedName = "shrink/hold selection"
combinedDescription = """
reduce selections to zero length / make all commands extend the selection
"""
description = """
reduce all selections to length zero
"""
command = "runCommands"
args.commands = [
  "selection-utilities.shrinkToActive",
  { command = "master-key.setFlag", args = { name = "select_on", value = false } },
]

[[bind]]
path = "edit.motion.mod"
key = "shift+v"
name = "hold selection"
combinedName = "shrink/hold selection"
description = """
all motions extend the selection
"""
command = "master-key.setFlag"
args.name = "select_on"
args.value = true

[[bind]]
path = "edit.action.open_lines"
name = "open, act →"
description = "without selection: open a line below current line and enter insert, with selection: move cursor to start"
key = "o"
combinedName = "open below/above, act →/←"
combinedKey = "o/shift+o"
combinedDescription = """
without selection: open a line below/above current line and enter insert, with selection: move cursor to end/start
of selection
"""
when = "!editorHasSelection"
command = "runCommands"
args.commands = ["editor.action.insertLineAfter", "master-key.enterInsert"]

[[bind]]
path = "edit.action.open_lines"
key = "o"
combinedName = "open below/above, act →/←"
when = "editorHasSelection"
command = "selection-utilities.activeAtEnd"

[[bind]]
path = "edit.action.open_lines"
name = "open blw, act ←"
combinedName = "open below/above, act →/←"
description = "without selection: open a line above current line and enter insert, with selection: move cursor to end"
key = "shift+o"
when = "!editorHasSelection"
command = "runCommands"
args.commands = ["editor.action.insertLineBefore", "master-key.enterInsert"]

[[bind]]
path = "edit.action.open_lines"
name = "open blw, act ←"
combinedName = "open below/above, act →/←"
description = "without selection: open a line above current line and enter insert, with selection: move cursor to end"
key = "shift+o"
when = "editorHasSelection"
command = "selection-utilities.activeAtStart"

[[bind]]
path = "edit.motion"
key = "shift+5"
name = "to bracket"
description = "Move to matching bracket"
command = "editor.action.jumpToBracket"

[[bind]]
path = "edit.motion.prim"
key = '\'
name = "→ sel"
combinedName = "→/← sel"
description = "select *just* the character to the right"
combinedDescription = "select *just* the character to the right"
combinedKey = 'shift+\/\'
mode = ["normal", "selectedit"]
command = "runCommands"

[[bind.args.commands]]
command = "selection-utilities.shrinkToActive"

[[bind.args.commands]]
command = "cursorMove"
args = { to = "right", select = true }
computedArgs = { value = "count" }

[[bind]]
path = "edit.motion.prim"
key = 'shift+\'
name = "← sel"
combinedName = "→/← sel"
description = "select *just* the character to the left"
mode = ["normal", "selectedit"]
command = "runCommands"

[[bind.args.commands]]
command = "selection-utilities.shrinkToActive"

[[bind.args.commands]]
command = "cursorMove"
args = { to = "left", select = true }
computedArgs = { value = "count" }

[[path]]
id = "edit.motion.mod"
name = "Modify Motion Effects"
description = "Keys that change how other motions work"
default.kind = "motion"

[[bind]]
path = "edit.motion.obj"
key = "shift+4"
name = "all"
description = "Select entire document"
command = "editor.action.selectAll"

[[bind]]
path = "edit.motion"
key = "shift+r"
name = "trim wht"
description = "trim external whitespace"
command = "selection-utilities.trimSelectionWhitespace"

[[bind]]
path = "edit.motion.obj"
name = "→ num."
description = "Move to next number"
key = "shift+3"
combinedName = "→/← num."
combinedDescription = "Move to next/prev number"
combinedKey = "shift+3/2"
args.unit = "number"
args.selectWhole = true
args.boundary = "both"
computedArgs.value = "(count || 1)"

[[bind]]
path = "edit.motion.obj"
name = "← num."
description = "Move to next number"
key = "shift+2"
combinedName = "→/← num."
args.unit = "number"
args.selectWhole = true
args.boundary = "both"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion"
name = 'narrow to subword'
description = "Narrow current selection so it starts and stops at a subword (e.g. 'snake' in snake_case)"
key = "z"
command = "selection-utilities.narrowTo"
args.unit = "subident"
args.boundary = "both"

# ## Repeating Motions

# Like VIM, the number keys (0-9) can be typed as a prefix to most commands and serve as a `count`
# argument to that command. In most cases this causes the command to be repeated `count`
# times e.g. 2w would select the next two words starting from the current cursor position.

[[bind]]
path = "edit.count"
foreach.num = ['{key: [0-9]}']
name = "count {num}"
key = "{num}"
command = "master-key.updateCount"
description = "Add digit {num} to the count argument of a command"
combinedKey = "0-9"
combinedName = "count 0-9"
combinedDescription = "Add digit 1-9 to count argument of a command"
args.value = "{num}"
resetTransient = false
mode = ["!insert", "!capture"]
hideInDocs = true

# There are several ways to repeat or undo previously entered commands, both actions and motions

[[path]]
id = "edit.motion.history"
name = "motion history"
description = "Commands that repeat some kind of motion"

[[bind]]
path = "edit.motion.history"
key = ";"
name = "repeat motion"
description = """
Repeat the last motion command. Motions usually move the cursor or change the selection.
"""
repeat = "count"
command = "master-key.replayFromHistory"
args.at = """
commandHistory[i].path.startsWith('edit.motion') &&
commandHistory[i].name != 'repeat motion' &&
commandHistory[i].name != 'shrink selection'
"""

[[bind]]
path = "edit.motion.history"
name = "repeat subject"
description = """
Repeat the subject: a motion command that occurred right before an action. For
instance `w` followed by `d` selects a word and deletes it. The `w` command would be the
last subject until some new action is run after `d`. See also `.` which repeats the last action.
"""
key = ","
command = "master-key.replayFromHistory"
args.at = """
commandHistory[i].path.startsWith("edit.motion") &&
commandHistory[i+1].path.startsWith("edit.action") &&
!(commandHistory[i+1].name.startsWith("repeat ") &&
  commandHistory[i+1].path.startsWith("edit.action.history"))
"""

[[bind]]
path = "edit.motion.history"
name = "cursor undo"
key = "-"
combinedName = "cursor undo/redo"
combinedKey = "-/shift+-"
command = "cursorUndo"

[[bind]]
path = "edit.motion.history"
name = "cursor redo"
combinedName = "cursor undo/redo"
key = "shift+-"
command = "cursorRedo"

[[bind]]
path = "edit.motion.history"
name = "nav ←"
description = "Go back in navigation history (e.g. goto definition)"
combinedName = "nav ←/→"
combinedKey = "n/shift+n"
combinedDescription = "Go back/forward in navigation history"
key = "g n"
command = "workbench.action.navigateBackInNavigationLocations"

[[bind]]
path = "edit.motion.history"
name = "nav →"
combinedName = "nav ←/→"
description = "Go forward in navigation history (e.g. goto definition)"
key = "g shift+n"
command = "workbench.action.navigateForwardInNavigationLocations"

[[bind]]
path = "edit.motion.history"
name = "edit hist ←"
description = "Go back in edit history"
key = "g -"
combinedName = "edit ←/→"
combinedKey = "-/shift+-"
combinedDescription = "Go back/forward in edit history"
command = "workbench.action.navigateBackInEditLocations"

[[bind]]
path = "edit.motion.history"
name = "edit hist →"
description = "Go forward in edit history)"
key = "g shift+-"
combinedName = "edit ←/→"
command = "workbench.action.navigateForwardInEditLocations"

# ## Search Motions

# Search motions accept one or more characters and select text up until the given character. Search commands are case insensitive by default. They can serve as very efficient ways to jump to a desired location. E.g. typing `sfod` in normal mode would delete the first three words of the following line of text
#
# > I want some food

[[path]]
id = "edit.motion.search"
name = "Search Related Motions"
description = "Motions related to searching for text in a document"
default.command = "master-key.search"
default.args.caseSensitive = false
default.args.backwards = false
default.args.selectTillMatch = true
default.args.wrapAround = true

[[bind]]
path = "edit.motion.search"
key = "/"
name = "search →"
description = "search forwards"
combinedName = "search → (←)"
combinedDescription = "search forwards (backwards)"
combinedKey = "/ (shift+/)"
args.offset = "start"
args.register = "search"

[[bind]]
path = "edit.motion.search"
key = "shift+/"
name = "search ←"
description = "search backwards"
combinedName = "search → (←)"
args.offset = "start"
args.register = "search"
args.backwards = true

[[bind]]
path = "edit.motion.search"
key = "n"
name = "→ search"
description = "Go to the next match of the search query"
command = "master-key.nextMatch"
args.register = "search"
computedArgs.repeat = "(count || 1)-1"

[[bind]]
path = "edit.motion.search"
key = "shift+n"
name = "← search"
description = "Go to the previous match of the search query"
command = "master-key.previousMatch"
args.register = "search"
computedArgs.repeat = "(count || 1)-1"

[[bind]]
path = "edit.motion.search"
key = "shift+8"
name = "match →"
description = "Next match to object under cursor"
combinedName = "match →/←"
combinedDescription = "Next/previous match to object under cursor"
combinedKey = "shift+8/7"
computedArgs.text = "firstSelectionOrWord"
args.offset = "start"
args.register = "search"

[[bind]]
path = "edit.motion.search"
key = "shift+7"
name = "match ←"
description = "Previous match to object under cursor"
combinedName = "match →/←"
computedArgs.text = "firstSelectionOrWord"
args.offset = "start"
args.register = "search"
args.backwards = true

[[bind]]
path = "edit.motion.search"
key = "f"
name = "find char"
description = "Find the next char (include char in selection)"
combinedName = "find char (back)"
combinedDescription = "Find the next (previous) char (include char in selection)"
combinedKey = "f (shift+f)"
args.acceptAfter = 1
computedArgs.skip = "count-1"
args.offset = "inclusive"

[[bind]]
path = "edit.motion.search"
key = "shift+f"
name = "find char back"
description = "Find the previous char (include char in selection)"
combinedName = "find char (back)"
args.acceptAfter = 1
args.offset = "inclusive"
args.backwards = true
computedArgs.skip = "count-1"

[[bind]]
path = "edit.motion.search"
key = "t"
name = "to char"
description = "Find the next char (exclude char in selection)"
combinedName = "to char (back)"
combinedKey = "t (shift+t)"
combinedDescription = "Find the next/previous char (exclude char in selection)"
args.acceptAfter = 1
args.offset = "start"
computedArgs.skip = "count-1"

[[bind]]
path = "edit.motion.search"
key = "shift+t"
name = "to char back"
description = "Find the previous char (exclude char in selection)"
combinedName = "to char (back)"
args.acceptAfter = 1
args.offset = "end"
args.backwards = true
computedArgs.skip = "count-1"

[[bind]]
path = "edit.motion.search"
key = "s"
name = "find char pair"
description = "To next character pair"
combinedName = "char pair →/←"
combinedDescription = "To next character pair"
combinedKey = "s/shift+s"
args.acceptAfter = 2
args.offset = "start"
computedArgs.skip = "count-1"
mode = "normal"

[[bind]]
path = "edit.motion.search"
key = "shift+s"
name = "char pair back"
description = "To previous character pair"
combinedName = "char pair →/←"
args.acceptAfter = 2
args.offset = "start"
computedArgs.skip = "count-1"
args.backwards = true

# ## Goto Commands

# Goto commands all begin with the mnemonic prefix key `g`. They are additional
# motion commands that compliment the basic motions listed in the previous section.

[[bind]]
path = "edit.motion"
key = "g"
priority = 1
name = "goto"
command = "master-key.prefix"
description = """
Goto commands move the location of the cursor (or the active selection position) forward
or backwards in some direction.
"""

[[bind]]
path = "edit.motion.prim"
key = "g j"
priority = 1
name = "unwrp ↓"
combinedName = "unwrap ↓/↑"
combinedKey = "j/k"
combinedDescription = """
move cursor up/down unwrapped text line; if a single line is wrapped into multiple lines by
the editor, this command skips all such wrapped lines
"""
description = """
down unwrapped line; if a single line is wrapped into multiple lines by the editor, this
command skips all such wrapped lines
"""
args.to = "down"
args.by = "line"

[[bind]]
path = "edit.motion.prim"
key = "g k"
priority = 1
name = "unwrp ↑"
combinedName = "unwrap ↓/↑"
description = "up unwrapped line"
args.to = "up"
args.by = "line"

[[bind]]
path = "edit.motion.prim"
key = "g shift+k"
priority = 1
combinedName = "unwrp sel ↑/↓"
combinedDescription = "select unwrapped lines up/down"
combinedKey = "shift+k/j"
name = "unwrp sel ↑"
description = "select unwrapped lines upwards"
command = "runCommands"

[[bind.args.commands]]
command = "selection-utilities.shrinkToActive"

[[bind.args.commands]]
command = "cursorMove"
args = { to = "up", by = "line", select = true }
computedArgs = { value = "count" }

[[bind.args.commands]]
command = "expandLineSelection"

[[bind]]
path = "edit.motion.prim"
key = "g shift+j"
priority = 1
name = "sel ↓"
combinedName = "unwrp sel ↑/↓"
description = "select unwrapped lines downwards"
command = "runCommands"

[[bind.args.commands]]
command = "selection-utilities.shrinkToActive"

[[bind.args.commands]]
command = "cursorMove"
args = { to = "down", by = "line", select = true }
computedArgs = { value = "count" }

[[bind.args.commands]]
command = "expandLineSelection"

[[bind]]
path = "edit.motion.prim"
key = "shift+g"
priority = 1
name = "doc end"
description = "select to end of document"
combinedName = "doc top/bottom"
combinedDescription = "select to top/bottom of document"
combinedKey = ",/."
command = "cursorBottomSelect"

[[bind]]
path = "edit.motion.prim"
key = "g g"
priority = 1
name = "doc start"
description = "select to start (line) of document."
command = "runCommands"
when = "master-key.count > 1"

[[bind.args.commands]]
command = "cursorTop"

[[bind.args.commands]]
command = "cursorMove"
args.to = "down"
args.by = "wrappedLine"
computedArgs.value = "count-1"

[[bind.args.commands]]
command = "revealLine"
args.at = "center"
computedArgs.lineNumber = "count"

[[bind]]
path = "edit.motion.prim"
key = "g g"
priority = 1
name = "doc start"
description = "select to start of document"
command = "cursorTopSelect"
when = "master-key.count <= 1"

[[bind]]
path = "edit.motion.obj"
key = "g w"
priority = 1
name = "WORD →"
combinedName = "WORD →/←"
combinedDescription = """
next/prev WORD;  e.g. contiguous non-whitespace region
"""
combinedKey = "w/b"
description = "next WORD; e.g. contiguous non-whitespace region"
args.unit = "WORD"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "g b"
priority = 1
name = "WORD ←"
combinedName = "WORD →/←"
description = "previous WORD; e.g. contiguous non-whitespace region"
args.unit = "WORD"
computedArgs.value = "-count || -1"

[[bind]]
path = "edit.motion.obj"
key = "g e"
priority = 1
name = "WORD end →"
description = "next WORD end; e.g. contiguous non-whitespace region"
args.unit = "WORD"
computedArgs.boundary = "around_on ? 'both' : 'end'"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "g 0"
priority = 1
name = "sec →"
description = "next section"
combinedName = "sec →/←"
combinedDescription = "next/previous section"
combinedKey = "0/9"
args.unit = "section"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.obj"
key = "g 9"
priority = 1
name = "sec ←"
description = "previous section"
combinedName = "sec →/←"
args.unit = "section"
computedArgs.value = "-(count || 1)"

[[path]]
id = "util"
name = "assorted misecellaneous commands"
default.kind = "util"
when = "editorTextFocus && !findWidgetVisible"

[[path]]
id = "window"
name = "Window Manipulation"
description = "Commands for navigating and manipulating the window/editor panes in some way"
default.kind = "util"
default.mode = "normal"
when = "editorTextFocus && !findWidgetVisible"

[[bind]]
path = "window"
name = "goto line"
priority = 1
description = "goto line command"
key = "g l"
command = "workbench.action.gotoLine"
when = "editorTextFocus"

[[bind]]
path = "window"
name = "to refs"
priority = 1
description = "jump to a location where this symbol is referenced"
key = "g r"
command = "editor.action.goToReferences"
when = "editorTextFocus"

[[bind]]
path = "window"
name = "go to"
priority = 1
description = "go to the definition of symbol under cursor"
key = "g d"
combinedName = "go to (aside)"
combinedKey = "(shift+)d"
combinedDescription = "go to the definition of symbol (in an editor to the side)"
command = "editor.action.revealDefinition"
when = "editorTextFocus"

[[bind]]
path = "window"
name = "go to, aside"
priority = 1
description = "go to the definition of symbol under cursor in an editor to the side"
key = "g shift+d"
combinedName = "go to (aside)"
command = "editor.action.revealDefinitionAside"
when = "editorTextFocus"

[[bind]]
path = "edit.motion"
key = "g c"
name = "cell →"
combinedName = "cell →/←"
command = "runCommands"
args.commands = ["jupyter.gotoNextCellInFile", "jupyter.selectCell"]
description = "previous jupyter notebook cell"

[[bind]]
path = "edit.motion"
key = "g shift+c"
name = "cell ←"
combinedName = "cell →/←"
description = "previous jupyter notebook cell"
command = "runCommands"
args.commands = ["jupyter.gotoPrevCellInFile", "jupyter.selectCell"]

# ## Match Commands

# Match commands select some syntactical region of text, e.g. in or around parenthesis, brackets, indent level etc... Where the `g` prefixed commands move forward or backward, these commands move both the start and the end of the selection away from the active cursor position. Repeating the command moves to the next (or previous) match, depending on the command.

# If you accidentally select `around` instead of `in`, you can revise your selection using `R` to narrow to non-white space or `z` to narrow to a subword (e.g. excludes `_`)

[[path]]
id = "edit.motion.match"
name = "Matching Motions"
description = "Motions that match some range of characters"

[[path]]
id = "edit.motion.match.obj"
name = "Matching Object Motions"
description = "Motions that match some range of characters by predefined regex"
default.command = "selection-utilities.moveBy"
default.kind = "motion"
default.args.selectWhole = true
default.args.boundary = "start"

[[bind]]
path = "edit.motion.match"
key = "m"
name = "match"
description = """
Find the closest character range matching a specified object.
"""
kind = "motion"
command = "master-key.prefix"

[[bind]]
path = "edit.motion.match"
key = "m m"
prefixes = [""]
name = "smart expand"
description = "Use VSCode's built-in smart expansion command"
command = "editor.action.smartSelect.expand"

[[bind]]
path = "edit.motion.match.obj"
key = "m w"
name = "around subwrd →"
description = "(camel/snake case)"
combinedName = "around subwrd ←/→"
combinedDescription = "(camel/snake case)"
combinedKey = "w/b"
args.unit = "subword"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m b"
name = "around subwrd ←"
description = "(camel/snake case)"
combinedName = "around subwrd ←/→"
args.unit = "subword"
computedArgs.value = "-count || -1"

[[bind]]
path = "edit.motion.match.obj"
key = "m shift+w"
name = "ard word →"
combinedName = "around word →/←"
combinedKey = "shift+w/b"
args.unit = "word"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m shift+b"
name = "ard word ←"
combinedName = "around word →/←"
prefixes = [""]
args.unit = "word"
computedArgs.value = "-count || -1"

[[bind]]
path = "edit.motion.match.obj"
key = "m e"
name = "in subwrd"
combinedName = "in → subword/word"
combinedKey = "e/shift+e"
args.unit = "subident"
args.boundary = "both"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m shift+e"
name = "in word"
combinedName = "in → subword/word"
args.unit = "word"
args.boundary = "both"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m p"
name = "in parag. →"
combinedName = "in paragraph →/←"
combinedKey = "p/o"
args.boundary = "both"
args.unit = "paragraph"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m o"
name = "in parag. ←"
combinedName = "in paragraph →/←"
args.unit = "paragraph"
args.boundary = "both"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.match.obj"
key = "m shift+p"
name = "arn parag. →"
combinedName = "around paragraph →/←"
combinedKey = "shift+p/shift+o"
args.unit = "paragraph"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m shift+o"
name = "arn parag. ←"
combinedName = "around paragraph →/←"
args.unit = "paragraph"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.match.obj"
key = "m 0"
name = "arn subsec →"
combinedName = "around subsection →/←"
combinedKey = "0/shift+0"
args.unit = "subsection"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m shift+0"
name = "arn subsec ←"
combinedName = "around subsection →/←"
args.unit = "subsection"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.match.obj"
key = "m 9"
name = "in subsec →"
combinedName = "in subsection →/←"
combinedKey = "9/shift+9"
args.unit = "subsection"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m shift+9"
name = "in subsec ←"
combinedName = "in subsection →/←"
args.unit = "subsection"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.match"
key = "m g"
name = "other..."
description = "additional objects to match..."
command = "master-key.prefix"

[[bind]]
path = "edit.motion.match.obj"
key = "m g 0"
name = "section →"
combinedName = "section →/←"
combinedKey = "0/9"
args.unit = "section"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m g 9"
name = "section ←"
combinedName = "section →/←"
args.unit = "section"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.match.obj"
key = "m g w"
name = "around WORD →"
combinedName = "around WORD →/←"
combinedKey = "w/b"
args.unit = "WORD"
computedArgs.value = "count || 1"

[[bind]]
path = "edit.motion.match.obj"
key = "m g b"
name = "around WORD ←"
combinedName = "around WORD →/←"
args.unit = "WORD"
computedArgs.value = "-(count || 1)"

[[bind]]
path = "edit.motion.match.obj"
key = "m g e"
name = "in WORD"
args.unit = "WORD"
args.boundary = "both"
computedArgs.value = "count || 1"

[[path]]
id = "edit.motion.match.syntax"
name = "Motions around syntactic objects (e.g. parentheses and quotes)"
description = """
selection commands that move by a predefined syntactic object like brackets and quotes
"""

[[bind]]
path = "edit.motion.match.syntax"
key = "m ["
name = "in parens"
combinedName = "in/arnd parens"
combinedKey = "[/shift+["
combinedDescription = """
expand inside/around parens/brackets/braces and their contents; repeated calls to this command
will seek out larger and larger scopes
"""
description = """
expand inside parens/brackets/braces and their contents; repeated calls to this command
will seek out larger and larger scopes
"""
command = "selection-utilities.expandWithinBrackets"

[[bind]]
path = "edit.motion.match.syntax"
key = "m shift+["
name = "arnd parens"
combinedName = "in/arnd parens"
description = """
expand inside parens/brackets/braces and their contents; repeated calls to this command
will seek out larger and larger scopes
"""
command = "selection-utilities.expandAroundBrackets"

[[bind]]
path = "edit.motion.match.syntax"
key = "m '"
name = "in quotes"
description = """
select within current quotes; repeated calls to this command
will seek out larger and larger scopes
"""
combinedName = "in/arnd quotes"
combinedKey = "'/shift+'"
combinedDescription = """
select within/around current quotes; repeated calls to this command
will seek out larger and larger scopes
"""
command = "bracketeer.selectQuotesContent"

[[bind]]
path = "edit.motion.match.syntax"
key = "m shift+'"
name = "around quotes"
combinedName = "in/arnd quotes"
description = """
select around current quotes; repeated calls to this command
will seek out larger and larger scopes
"""
command = "runCommands"
args.commands = [
  "bracketeer.selectQuotesContent",
  "bracketeer.selectQuotesContent",
]

[[bind]]
path = "edit.motion.match.syntax"
key = "m shift+."
name = "in <>"
description = "text inside angle brackets"
combinedName = "in <> / in ><"
combinedKey = "shift+. / shift+,"
combinedDescription = "text inside angle brackets / pairs (e.g. text in <a>text</a>)"
command = "extension.selectAngleBrackets"

[[bind]]
path = "edit.motion.match.syntax"
key = "m shift+,"
name = "in ><"
combinedName = "in <> / in ><"
description = "text inside tag pairs (e.g. <a>text</a>)"
command = "extension.selectInTag"


[[path]]
id = "edit.motion.match.cell"
name = "Matching Object Motions"
description = "Motions that match some range of characters by predefined regex"

[[bind]]
path = "edit.motion.match.cell"
name = "in cell"
description = "select text within a cell (ala jupyter)"
key = "m c"
command = "jupyter.selectCell"

[[path]]
id = "edit.motion.searchpair"
name = "Search pairs"
description = "Find text that falls between pairs of characters"

[[bind]]
path = "edit.motion.searchpair"
name = "between pair"
combinedDescription = """
Select between pairs of the same N characters (t) or distinct sets of N
characters (s), where N is the count. Examples:
2mt'' would search for a string between `''` and `''`.
2ms,,.. would search for a string between `,,` and `..`.
"""
key = "m t"
command = "runCommands"
combinedName = "between pair/two"
combinedKey = "t/s"
description = """
Select between pairs of the same N characters, where N is the count.
Example: 2mt'' would search for a string between '' and ''.
"""

[[bind.args.commands]]
command = "master-key.captureKeys"
computedArgs.acceptAfter = "count || 1"

[[bind.args.commands]]
command = "selection-utilities.selectBetween"
computedArgs.str = "captured"
args.inclusive = false

[[bind]]
path = "edit.motion.searchpair"
name = "between two"
description = """
Select between two different sets of N characters, where N is the count e.g.
2ms,,.. would search for a string between ,, and ..
"""
key = "m s"
combinedName = "between pair/two"
command = "runCommands"

[[bind.args.commands]]
command = "master-key.captureKeys"
computedArgs.acceptAfter = "2*(count || 1)"

[[bind.args.commands]]
command = "selection-utilities.selectBetween"
computedArgs.between.from = "captured.slice(0, captured.length/2)"
computedArgs.between.to = "captured.slice(captured.length/2)"
args.inclusive = false

# ## Simple Actions

# These are the most common, basic actions available in Larkin that can be used
# to edit text in relation to the current selection.

[[path]]
id = "edit.action"
name = "Actions"
description = "Commands that modify the document or UI"
default.kind = "action"
default.mode = "normal"

[[path]]
id = "edit.action.basic"
name = "Basic Actions"
description = "Essential actions required to edit text"

[[bind]]
path = "edit.action.basic"
#- TODO: add documentation to these basic editor keys
key = "i"
name = "insert"
description = "Switch to insert mode (right before character)"
command = "runCommands"
args.commands = ["selection-utilities.shrinkToActive", "master-key.enterInsert"]
mode = ["normal", "selectedit", "syminsert"]

[[bind]]
path = "edit.action.basic"
key = "a"
name = "append"
description = "insert after cursor"
mode = ["normal", "selectedit", "syminsert"]
command = "runCommands"
args.commands = [
  "selection-utilities.shrinkToActive",
  "cursorRight",
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "shift+i"
name = "insert start"
mode = ["normal", "selectedit", "syminsert"]
command = "runCommands"
args.commands = [
  { command = "cursorMove", args = { to = "wrappedLineFirstNonWhitespaceCharacter", select = false } },
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "shift+a"
name = "insert end"
mode = ["normal", "selectedit", "syminsert"]
command = "runCommands"
args.commands = [
  { command = "cursorMove", args = { to = "wrappedLineEnd", select = false } },
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "c"
name = "change"
description = """
Without a count: change selected region of text. With a count:
change up to `count` lines.
"""
when = "editorHasMultilineSelection"
command = "runCommands"
args.commands = [
  "deleteRight",
  "editor.action.insertLineBefore",
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "c"
when = "!editorHasMultilineSelection && editorHasSelection"
command = "runCommands"
args.commands = ["deleteRight", "master-key.enterInsert"]

[[bind]]
path = "edit.action.basic"
key = "c"
when = "!editorHasSelection && master-key.count <= 1"
command = "runCommands"
args.commands = [
  "expandLineSelection",
  "deleteRight",
  "editor.action.insertLineBefore",
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "c"
when = "!editorHasSelection && master-key.count > 1"
command = "runCommands"
args.commands = [
  { defined = "selectLinesDown" },
  "deleteRight",
  "editor.action.insertLineBefore",
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "shift+c"
name = "change to/back"
description = """Without a count: change from current char to end of line. With a count:
change the previous `count` lines.
"""
mode = "normal"
when = "master-key.count <= 1"
command = "runCommands"
args.commands = [
  "selection-utilities.shrinkToActive",
  "deleteAllRight",
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "shift+c"
mode = ["normal", "selectedit"]
when = "master-key.count > 1"
command = "runCommands"
args.commands = [
  { defined = "selectLinesUp" },
  "deleteRight",
  "editor.action.insertLineBefore",
  "master-key.enterInsert",
]

[[bind]]
path = "edit.action.basic"
key = "x"
mode = "normal"
name = "delete char"
command = "runCommands"
args.commands = [
  "selection-utilities.shrinkToActive",
  { command = "cursorMove", args = { to = "right", select = true }, computedArgs = { value = "count" } },
  "editor.action.clipboardCutAction",
]

[[bind]]
path = "edit.action.basic"
key = "r"
name = "replace char"
description = "replace the character under the cursor"
command = "master-key.replaceChar"

[[bind]]
path = "edit.action.basic"
key = "ctrl+i"
name = "insert char"
mode = ["normal", "selectedit"]
description = "insert a character in front of the cursor"
command = "master-key.insertChar"

[[path]]
id = "edit.action.clipboard"
name = "Clipboard Operations"
description = "Operations that manipulate the clipboard in some way."

[[bind]]
path = "edit.action.clipboard"
key = "p"
name = "paste after"
description = "Paste clipboard after the cursor/selection"
combinedName = "paste before/after/in"
combinedDescription = "Paste clipboard before/after/at the cursor/selection"
combinedKey = "p/shift+p/ctrl+p"
when = "editorHasSelection"
command = "runCommands"
args.commands = [
  "selection-utilities.activeAtEnd",
  "selection-utilities.shrinkToActive",
  "editor.action.clipboardPasteAction",
]

[[bind]]
path = "edit.action.clipboard"
key = "p"
name = "paste after"
combinedName = "paste before/after/in"
when = "!editorHasSelection"
command = "runCommands"
args.commands = ["cursorRight", "editor.action.clipboardPasteAction"]

[[bind]]
path = "edit.action.clipboard"
key = "ctrl+p"
when = "!suggestWidgetVisible"
mode = ["normal", "insert"]
name = "paste in"
combinedName = "paste before/after/in"
description = "Paste clipboard at location"
command = "editor.action.clipboardPasteAction"

[[bind]]
path = "edit.action.clipboard"
key = "shift+p"
name = "paste before"
combinedName = "paste before/after"
description = "Paste before the cursor/selection"
when = "editorHasSelection"
command = "runCommands"
args.commands = [
  "selection-utilities.activeAtStart",
  "selection-utilities.shrinkToActive",
  "editor.action.clipboardPasteAction",
]

[[bind]]
path = "edit.action.clipboard"
key = "shift+p"
combinedName = "paste before/after"
when = "!editorHasSelection"
command = "runCommands"
args.commands = ["cursorRight", "editor.action.clipboardPasteAction"]

[[bind]]
path = "edit.action.history"
name = "repeat action"
description = """
Repeat the last action command. Actions usually modify the text of a document in one way or
another. (But, e.g. sending text to the REPL is also considered an editor action).
See also `,` which repeats the last subject.
"""
key = "."
command = "runCommands"
repeat = "count"

[[bind.args.commands]]
command = "master-key.replayFromHistory"
#- we can repeat any action but history-related actions; we make an exception for replaying macros, which can be repeated
args.at = """
commandHistory[i].path.startsWith('edit.action') &&
(!commandHistory[i].path.startsWith('edit.action.history') ||
 commandHistory[i].name == 'replay')
"""

[[bind.args.commands]]
command = "master-key.enterNormal"

[[bind]]
path = "edit.action.history"
name = "undo"
key = "u"
command = "runCommands"
args.commands = ["undo", "selection-utilities.shrinkToActive"]

[[bind]]
path = "edit.action.history"
name = "redo"
key = "shift+u"
command = "runCommands"
args.commands = ["redo", "selection-utilities.shrinkToActive"]

[[bind]]
path = "edit.action.clipboard"
key = "d"
name = "delete"
description = """
Without a count: delete selected text (and store to clipboard). With a
count, delete up to the next `count` lines and store to clipboard.
"""
when = "!editorHasSelection"
command = "runCommands"
args.commands = [
  { defined = "selectLinesDown" },
  "editor.action.clipboardCutAction",
  { command = "master-key.setMode", args = { value = "normal" } },
]

[[bind]]
path = "edit.action.clipboard"
key = "d"
when = "editorHasSelection"
command = "runCommands"
args.commands = [
  "editor.action.clipboardCutAction",
  { command = "master-key.setMode", args = { value = "normal" } },
]

[[bind]]
path = "edit.action.clipboard"
key = "shift+d"
mode = "normal"
name = "without count: Delete from cursor to end of line; with count: Delete from current line up `count` number of keys."
command = "runCommands"
args.commands = [
  "selection-utilities.shrinkToActive",
  { command = "cursorMove", args = { to = "wrappedLineEnd", select = true } },
  "editor.action.clipboardCutAction",
]

[[bind]]
path = "edit.action.clipboard"
key = "shift+d"
mode = "normal"
when = "master-key.count > 1"
command = "runCommands"
args.commands = [{ defined = "selectLinesUp" }, "deleteRight"]

[[bind]]
path = "edit.action.clipboard"
key = "y"
name = "copy"
description = "copy selected text to clipboard"
command = "runCommands"
args.commands = [
  "editor.action.clipboardCopyAction",
  "selection-utilities.shrinkToActive",
]

[[bind]]
path = "edit.action.clipboard"
key = "y"
when = "master-key.count > 1"
command = "runCommands"
args.commands = [
  { defined = "selectLinesDown" },
  "editor.action.clipboardCopyAction",
  "selection-utilities.shrinkToActive",
]

[[bind]]
path = "edit.action.clipboard"
key = "shift+y"
name = "copy (eol/up)"
description = "without a count: copy to end of line; with a count: copy this and the previous N lines"
when = "master-key.count <= 1"
command = "runCommands"
args.commands = [
  "selection-utilities.shrinkToActive",
  { command = "cursorMove", args = { to = "wrappedLineEnd", select = true } },
  "editor.action.clipboardCopyAction",
  "selection-utilities.shrinkToActive",
]

[[bind]]
path = "edit.action.clipboard"
key = "shift+y"
when = "master-key.count > 1"
command = "runCommands"
args.commands = [
  { defined = "selectLinesUp" },
  "editor.action.clipboardCopyAction",
  "selection-utilities.shrinkToActive",
]

[[path]]
id = "edit.action.open_lines"
name = "Line opening actions"
description = """
These commands provides several ways of adding lines above or below the current line
"""

[[path]]
id = "edit.action.indent"
name = "Indentation"
description = """
Operations that affect line indentation
"""

[[bind]]
path = "edit.action.indent"
key = "shift+."
name = "indent"
description = "Indent lines"
command = "editor.action.indentLines"

[[bind]]
path = "edit.action.indent"
key = "shift+."
name = "indent"
description = "Indent lines"
when = "master-key.count >= 1"
command = "runCommands"
args.commands = [{ defined = "selectLinesDown" }, "editor.action.indentLines"]

[[bind]]
path = "edit.action.indent"
key = "shift+,"
name = "deindent"
when = "master-key.count < 1"
description = "De-indent lines"
command = "editor.action.outdentLines"

[[bind]]
path = "edit.action.indent"
key = "shift+,"
name = "deindent"
when = "master-key.count >= 1"
description = "Deindent lines"
command = "runCommands"
args.commands = [
  { defined = "selectLinesDown" },
  "editor.action.outdentLines",
  "selection-utilities.shrinkToActive",
]

[[path]]
id = "edit.action.history"
name = "History Commands"
description = "Commands that interact with edit or cursor history."

# ## Number actions

# These commands modify or enter numbers in some way.

[[path]]
id = "edit.action.numbers"
name = "Number Editing"
description = "Commands that modify one or more numbers"

[[bind]]
path = "edit.action.numbers"
name = 'inc #'
description = "Increment a number by 1"
key = "="
command = "selection-utilities.incrementNumber"

[[bind]]
path = "edit.action.numbers"
name = 'dec #'
description = "Decrement a number by 1 "
key = "shift+="
command = "selection-utilities.decrementNumber"

# ## Captilization

# These modify the capitalization of letters in some way.

[[path]]
id = "edit.action.capitals"
name = "Capitlization Actions"
description = "Actions that change how words are capitalized"
default.mode = ["normal", "selectedit"]

[[bind]]
path = "edit.action.capitals"
name = 'camel'
description = "Swap style to lower camel case (`camelCase`)"
key = "` c"
command = "extension.changeCase.camel"

[[bind]]
path = "edit.action.capitals"
name = 'constant'
description = "Swap style to constant (`IS_CONSTANT`)"
key = "` shift+u"
command = "extension.changeCase.constant"

[[bind]]
path = "edit.action.capitals"
name = 'dot'
description = "Swap style to dot case (`dot.case`)"
key = "` ."
command = "extension.changeCase.dot"

[[bind]]
path = "edit.action.capitals"
name = 'kebab'
description = "Swap style to kebab case (`kebab-case`)"
key = "` -"
command = "extension.changeCase.kebab"

[[bind]]
path = "edit.action.capitals"
name = 'all lower'
description = "Swap all to lower case"
key = "` shift+l"
command = "extension.changeCase.lower"

[[bind]]
path = "edit.action.capitals"
name = 'first lower'
description = "Swap first letter to lower case"
key = "` l"
command = "extension.changeCase.lowerFirst"

[[bind]]
path = "edit.action.capitals"
name = 'spaces'
description = "Swap to spaces (`camelCase` -> `camel case`)"
key = "` space"
command = "extension.changeCase.no"

[[bind]]
path = "edit.action.capitals"
name = 'Camel'
description = "Swap to upper camel case (`CamelCase`)"
key = "` shift+c"
command = "extension.changeCase.pascal"

[[bind]]
path = "edit.action.capitals"
name = 'path'
description = "Swap to 'path' case (`path/case`)"
key = "` /"
command = "extension.changeCase.path"

[[bind]]
path = "edit.action.capitals"
name = 'snake'
description = "Swap to snake case (`snake_case`)"
key = "` shift+-"
command = "extension.changeCase.snake"

[[bind]]
path = "edit.action.capitals"
name = 'swap'
description = "Swap upper and lower case letters"
key = "` s"
command = "extension.changeCase.swap"

[[bind]]
path = "edit.action.capitals"
name = 'title'
description = "Swap to title case (all words have first upper case letter)"
key = "` t"
command = "extension.changeCase.title"

[[bind]]
path = "edit.action.capitals"
name = 'all upper'
description = "Swap to use all upper case letters"
key = "` shift+y"
command = "extension.changeCase.upper"

[[bind]]
path = "edit.action.capitals"
name = 'first upper'
description = "Swap first character to upper case"
key = "` u"
command = "extension.changeCase.upperFirst"

# ## Repeat actions

# These commands interact with the history of previously typed commands to repeat some sequence of commands. They can record any edits, and any commands that are issued through master key bindings. Commands that are not part of this binding file (e.g. a standard call to Cmd/Ctrl+V to paste) will not be recorded. You can copy your non-master-key bindings over to master key (so that they will be recorded) by [customizing your bindings](#customized-bindings) and using `Import Default Bindings` and `Import User Bindings` to allow all of the default and user bindings stored in VSCOde's normal keybinding files to be recorded by master key. (You will have to remove your original user bindings from the VSCOde `keybinding.json` file manually)

[[bind]]
path = "edit.action.history"
name = "record"
description = "Start/stop recording Master Key commands"
key = "shift+q"
when = "!master-key.record"
command = "master-key.record"
args.on = true

[[bind]]
path = "edit.action.history"
name = "record"
description = """
Start/stop recording key presses defined by Master Key pushing it to the
top of the `history` stack once recording finishes."
"""
key = "shift+q"
when = "master-key.record"
command = "runCommands"

[[bind.args.commands]]
command = "master-key.record"
args.on = false

[[bind.args.commands]]
command = "master-key.pushHistoryToStack"
args.range.from = 'commandHistory[i-1].name === "record"'
args.range.to = "i"

[[bind]]
path = "edit.action.history"
name = "replay"
description = """
Replay the Master Key command sequence at the top of the `history` stack. Specifying
a count requests the Nth most recent item on this stack.
"""
key = "q q"
command = "master-key.replayFromStack"
computedArgs.index = "count"

[[bind]]
path = "edit.action.history"
name = "store macro"
description = """
Stores the top of the `history` stack into a named register. Specifying a count stores the
Nth most recent item on this stack.
"""
key = "q s"
command = "master-key.storeNamed"
args.description = "Save Macro"
args.name = "macro"
args.contents = "macro[macro.length-(count || 0)-1]"

[[bind]]
path = "edit.action.history"
name = "replay stored"
description = """
Replay a recorded Master Key command sequence from a named register, pushing
it to the front of the history stack.
"""
key = "q r"
command = "runCommands"

[[bind.args.commands]]
command = "master-key.restoreNamed"
args.description = "Macro"
args.name = "macro"

[[bind.args.commands]]
command = "master-key.pushHistoryToStack"
computedArgs.value = "captured"

[[bind.args.commands]]
command = "master-key.replayFromStack"
args.index = 0

[[bind]]
path = "edit.action.history"
name = "store last"
description = """
Store the N most recently run commands as a macro, where N is the count (defaulting to 1).
"""
key = "q l"
command = "master-key.pushHistoryToStack"
args.range.from = "i-(count || 0)"
args.range.to = "i"

# ## Utility Commands

# These actions include miscellaneous utilities.

[[bind]]
path = "window"
key = "shift+ctrl+;"
name = "palette"
resetTransient = false
hideInPalette = true
mode = []
prefixes = "<all-prefixes>"
description = """
show command suggestions within the context of the current mode and keybinding prefix
(if any keys have already been typed)
"""
command = "master-key.commandPalette"

# ## Select-edit Mode

# Select-edit mode allows you make a variety of kakoune-like modifications of one or more cursors. This lends itself to work flows such as:
#
# - select every line of text as a separate cursor, then filter out the lines you don't want
# - split an array by comma delimiters and edit each element of the array.
# - save a single selection to a list of selections to use for later and
# then move the cursor to the next selection you wish to add

[[path]]
id = "edit.select_edit"
name = "Selection Editing"
description = "Various kakaune inspired commands for editing multiple selections"
default.mode = "selectedit"
default.kind = "motion"

[[bind]]
path = "edit.select_edit"
name = "select-edit"
description = """
Enter a mode where you can edit and manipulate (possibly multiple) selections.
"""
key = "'"
command = "master-key.setMode"
args.value = "selectedit"
mode = "normal"

[[bind]]
path = "edit.select_edit"
key = "shift+'"
combinedName = "rm cursors"
combinedKey = "shift/ctrl+'"
combinedDescription = "Delete all selections and return to normal (multiple key variants)"
name = "del. cursors"
description = "Delete all selections and return to normal"
command = "runCommands"
args.commands = [
  "selection-utilities.cancelSelection",
  "master-key.enterNormal",
]
mode = ["selectedit", "normal"]

[[bind]]
path = "edit.select_edit"
key = "ctrl+'"
mode = ["insert", "selectedit", "normal"]
name = "rm cursors"
combinedName = "rm cursors"
description = "Delete all selections and return to normal"
command = "runCommands"
args.commands = [
  "selection-utilities.cancelSelection",
  "master-key.enterNormal",
]

[[bind]]
path = "edit.select_edit"
name = 'normal'
description = "return to normal mode"
key = "'"
command = "master-key.enterNormal"

[[bind]]
path = "edit.select_edit"
name = "add →"
combinedName = "add →/←"
description = "add cursor at the next match to the primary cursor's text"
combinedDescription = "add cursor at the next/previous match to the primary cursor's text"
key = "l"
combinedKey = "l/h"
repeat = "count"
command = "selection-utilities.addNext"

[[bind]]
path = "edit.select_edit"
name = "add ←"
combinedName = "add →/←"
description = "add cursor at the previous match to the primary cursor's text"
key = "h"
command = "selection-utilities.addPrev"
repeat = 'count'

[[bind]]
path = "edit.select_edit"
name = "skip →"
combinedName = "skip →/←"
description = "move primary cursor to the next match of the primary cursor's text"
combinedDescription = "move primary cursor to the next/previous match of the primary cursor's text"
key = "shift+l"
combinedKey = "shift+l/h"
command = "selection-utilities.skipNext"
repeat = "count"

[[bind]]
path = "edit.select_edit"
name = "skip ←"
combinedName = "skip →/←"
description = "move primary cursor to the previous match of the primary cursor's text"
key = "shift+h"
command = "selection-utilities.skipPrev"
repeat = 'count'

[[bind]]
path = "edit.select_edit"
name = "align ←"
description = "align selections left"
key = "="
command = "selection-utilities.alignSelectionsLeft"

[[bind]]
path = "edit.select_edit"
name = "align →"
description = "align selections right"
key = "shift+="
command = "selection-utilities.alignSelectionsRight"

[[bind]]
path = "edit.select_edit"
name = "→ sel"
combinedName = "→/← sel"
description = """
make the next selection primary; primary selections determine from where you add cursors,
what cursor you delete, and where the cursor goes when you clear or save selections
"""
combinedDescription = """
make the next/previous selection primary; primary selections determine from where you add cursors,
what cursor you delete, and where the cursor goes when you clear or save selections
"""
key = "j"
combinedKey = "j/l"
command = "selection-utilities.movePrimaryRight"
repeat = 'count'

[[bind]]
path = "edit.select_edit"
name = "← sel"
combinedName = "→/← sel"
description = "make the previous selection primary; primary selections determine from where you add cursors, what cursor you delete, and where the cursor goes when you clear or save selections"
key = "k"
command = "selection-utilities.movePrimaryLeft"
repeat = 'count'

[[bind]]
path = "edit.select_edit"
name = "insert ↑"
combinedName = "insert ↑/↓"
description = """
insert cursor on line above
"""
combinedDescription = "insert cursor on line above/below"
key = "shift+k"
combinedKey = "shift+k/j"
command = "editor.action.insertCursorAbove"
repeat = "count"

[[bind]]
path = "edit.select_edit"
name = "insert sel ↓"
combinedName = "insert ↑/↓"
description = """
insert cursor on line below
"""
key = "shift+j"
command = "editor.action.insertCursorBelow"
repeat = "count-1"

[[bind]]
path = "edit.select_edit"
name = "del. primary"
combinedName = "del. primary/others"
description = "remove the primary selection"
combinedDescription = """
Remove either the primary selection or all selections. Return to normal
mode if all selections are deleted.
"""
key = "d"
command = "selection-utilities.deletePrimary"
repeat = "count-1"

[[bind]]
path = "edit.select_edit"
name = 'del. others'
description = "delete all other cursors but the primary selection"
key = "shift+d"
command = "removeSecondaryCursors"

[[bind]]
path = "edit.select_edit"
name = "save sel"
description = """
save all selections to the default register.
Use a count to specify an alternate register
"""
key = "c"
command = "runCommands"
args.commands = [
  { command = "selection-utilities.appendToMemory", computedArgs = { register = "count || 'default'" } },
  "selection-utilities.shrinkToActive",
  "master-key.enterNormal",
]

[[bind]]
path = "edit.select_edit"
name = "load sel"
description = """
load previously saved selections in the default register.
Use a count to specify an alternate register
"""
key = "v"
command = "runCommands"
args.commands = [
  { command = "selection-utilities.restoreAndClear", computedArgs = { register = "count || 'default'" } },
]

[[bind]]
path = "edit.select_edit"
name = "exchange sel"
description = """
exchange selections: with no saved selection, saves the selection, with saved selections exchanges text of current selections with those of the saved selections (number of selections must match). Use a count to specify an alternate register.
"""
key = "x"
command = "runCommands"
args.commands = [
  { command = "selection-utilities.swapWithMemory", computedArgs = { register = "count || 'default'" } },
  "master-key.enterNormal",
]

[[bind]]
path = "edit.select_edit"
name = "rem saved sel"
description = """
remove the most recently saved selection from the list of saved selections
"""
command = "runCommands"
key = "n"
args.commands = [
  { command = "selection-utilities.deleteLastSaved", computedArgs = { register = "count || 'default'" } },
  "master-key.enterNormal",
]

[[bind]]
path = "edit.select_edit"
key = "shift+enter"
name = "split sel"
description = """
split selection into multiple selections by new line charactesr
"""
command = "selection-utilities.splitByNewline"

[[bind]]
path = "edit.select_edit"
name = "sel all"
description = """
create a selection for every match of the current word (or selection)
"""
key = "shift+8"
command = "editor.action.selectHighlights"

[[bind]]
path = "edit.select_edit"
name = "character"
description = "split by a given character"
key = "s"
command = "runCommands"

[[bind.args.commands]]
command = "master-key.captureKeys"
args.acceptAfter = 1

[[bind.args.commands]]
command = "selection-utilities.splitBy"
computedArgs.text = "captured"

[[bind]]
path = "edit.select_edit"
name = "string"
description = "split by a given string"
key = "shift+s"
command = "selection-utilities.splitBy"

[[bind]]
path = "edit.select_edit"
name = "include"
description = """
Include all selections that contain a given marker
"""
key = "f"
command = "selection-utilities.includeBy"

[[bind]]
path = "edit.select_edit"
name = "exclude"
description = """
Exclude all selections that contain a given marker
"""
key = "shift+f"
command = "selection-utilities.excludeBy"

[[bind]]
path = "edit.select_edit"
name = "create"
description = "create selections of given string scoped to the current selections"
key = "/"
command = "selection-utilities.createBy"

[[bind]]
path = "edit.select_edit"
name = "regex"
description = "operations by regex rather than string"
key = "r"
command = "master-key.prefix"

[[bind]]
path = "edit.select_edit"
name = "split"
description = "split by a given regular expression"
key = "r shift+s"
command = "selection-utilities.splitByRegex"

[[bind]]
path = "edit.select_edit"
name = "create"
description = "create selections of given regular expression scoped to the current selections"
key = "r /"
command = "selection-utilities.createByRegex"

[[bind]]
path = "edit.select_edit"
name = "include"
description = "Include all selections that contain a given regular expression"
key = "r f"
command = "selection-utilities.includeByRegex"

[[bind]]
path = "edit.select_edit"
name = "exclude"
description = "Exclude all selections that contain a given regular expression"
key = "r shift+f"
command = "selection-utilities.excludeByRegex"

[[bind]]
path = "edit.select_edit"
key = "o"
name = "active to front"
combinedKey = "o/shift+o"
combinedName = "active to start/end"
combinedDescription = "move cursor to start/end of selection"
description = "move cursor to start of selection"
command = "selection-utilities.activeAtEnd"

[[bind]]
path = "edit.select_edit"
name = "active to end"
combinedName = "active to start/end"
description = "move cursor to back of selection"
key = "shift+o"
command = "selection-utilities.activeAtStart"

# ## Symmetric Insert Mode

# Symmetric insert mode allows you to edit text at both the start and the beginning of a selection. When entering a character with a complimentary pair (e.g. `(` to `)`) entry is handled in the expected way. For example if you type `(` at the start of a selection while in symmetric insert mode, `)` will apepar at the end of the selection.

# As a general rule, the letter keys issue commands of various sorts, and the other keys can be used to enter text (since we rarley want to surround a selection with an `a` but might want to surround it with `*` or `/`.

[define.braces]

"{".before = "{"
"{".after = "}"
"}".before = "{"
"}".after = "}"

"[".before = "["
"[".after = "]"
"]".before = "["
"]".after = "]"

"(".before = "("
"(".after = ")"
")".before = "("
")".after = ")"

"<".before = "<"
"<".after = ">"
">".before = "<"
">".after = ">"

[[mode]]
name = "syminsert"
highlight = "Highlight"
cursorShape = "BlockOutline"
lineNumbers = "relative"

[[mode.onType]]
command = "selection-utilities.insertAround"
computedArgs.before = "braces[captured].before || captured"
computedArgs.after = "braces[captured].after || captured"
args.followCursor = true

[[path]]
id = "edit.action.symmetric"
name = "Symmetric Operations"
description = "Operations that occur at both ends of a selection"
default.kind = "action"
default.mode = "syminsert"

[[path]]
id = "edit.motion.symmetric"
name = "Symmetric Motions"
description = "Motions that occur at both ends of a selection"
default.kind = "motion"
default.mode = "syminsert"

[[bind]]
path = "edit.action.symmetric"
name = "Normal"
description = "Return to normal model"
key = "enter"
command = "master-key.setMode"
mode = "syminsert"

[[bind]]
path = "edit.action.symmetric"
foreach.key = ["{key: [a-z]}", "shift+{key: [a-z]}"]
name = ""
description = "this key is ignored and has no associated command in syminsert mode"
key = "{key}"
command = "master-key.ignore"
mode = "syminsert"

[[bind]]
name = "esc. char"
path = "edit.action.symmetric"
key = "\\"
description = "Insert escaped character"
command = "runCommands"

[[bind.args.commands]]
command = "master-key.captureKeys"
args.acceptAfter = 1

[[bind.args.commands]]
command = "selection-utilities.insertAround"
computedArgs.before = "'\\\\' + (braces[captured].before || captured)"
computedArgs.after = "'\\\\' + (braces[captured].after || captured)"
args.followCursor = true

[[bind]]
path = "edit.action.symmetric"
name = "delete"
key = "x"
description = """
delete the first and last adjacent character when cursor is at end of selection and
delete the first and last character *in* the selection when cursor is at the start of the
selection
"""
command = "selection-utilities.deleteAround"
computedArgs.count = "count"
args.followCursor = true

[[bind]]
path = "edit.motion.symmetric"
key = "l"
name = "sel →"
description = "shrink/grow selections in direction that's rightwards from cursor"
command = "selection-utilities.adjustSelections"
args.dir = "forward"
computedArgs.count = "count"

[[bind]]
path = "edit.motion.symmetric"
key = "h"
name = "sel ←"
description = "shrink/grow selections in direction that's leftwards from cursor"
command = "selection-utilities.adjustSelections"
args.dir = "backward"
computedArgs.count = "count"

[[bind]]
path = "edit.motion.symmetric"
key = "o"
name = "active to front"
combinedKey = "o/shift+o"
combinedName = "active to start/end"
combinedDescription = "move cursor to start/end of selection"
description = "move cursor to start of selection"
command = "selection-utilities.activeAtEnd"

[[bind]]
path = "edit.motion.symmetric"
name = "active to end"
combinedName = "active to start/end"
description = "move cursor to back of selection"
key = "shift+o"
command = "selection-utilities.activeAtStart"

[[bind]]
path = "edit.action.symmetric"
name = "undo"
key = "u"
command = "undo"

[[bind]]
path = "edit.action.symmetric"
name = "redo"
key = "shift+u"
command = "redo"

[[bind]]
path = "edit.motion.symmetric"
key = "v"
name = "shrink selection"
description = """
reduce all selections to length zero and return to normal mode
"""
command = "runCommands"
args.commands = [
  "selection-utilities.shrinkToActive",
  { command = "master-key.setFlag", args = { name = "select_on", value = false } },
  "master-key.enterNormal",
]
